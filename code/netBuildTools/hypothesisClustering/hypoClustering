#!/home/jsybran/bin/julia-v0.6/bin/julia -p 24
#=
This will cluster hypotheses based on their set similarities
=#


using ArgParse
using NMFk

function main()
  s = ArgParseSettings()
  @add_arg_table s begin
    "--dijkstra-file", "-d"
      help = "Path to the dijkstra + cloud file."
      arg_type = String
      required = true
    "--label-file", "-l"
      help = "Path to the graph label file for readability."
      arg_type = String
      required = true
    "--read-tmp-file", "-r"
      help = "Path to existing matrix A"
      arg_type = String
    "--write-tmp-file", "-w"
      help = "Path to write resulting matrix A"
      arg_type = String
    "--write-result-file", "-f"
      help = "Path to write resulting matrix factors and cluster data."
      arg_type = String
    "--start-k", "-s"
      help = "First k to start trying, must be less than --end-k"
      arg_type = Int
      default = 1
    "--end-k", "-e"
      help = "Last k to start trying, must be greater than --start-k"
      arg_type = Int
      default = 5
    "--verbose", "-v"
      action = :store_true
  end

  args = parse_args(ARGS, s)

  dijkPath = args["dijkstra-file"]
  labelPath = args["label-file"]
  verbose = args["verbose"]
  readPath = args["read-tmp-file"]
  writePath = args["write-tmp-file"]
  startK = args["start-k"]
  endK = args["end-k"]
  resFilePath = args["write-result-file"]

  @assert startK > 0
  @assert endK >= startK

  local keyArr
  local SimMatrix

  if readPath != nothing
    verbose && println("Loading Sim Matrix")
    open(readPath) do file
      (keyArr, SimMatrix) = deserialize(file)
    end
  else
    verbose && println("creating Sim Matrix")


    labels = []
    open(labelPath) do labelFile
      labels = [strip(line) for line in eachline(labelFile)]
    end

    clouds = Dict{String, Set}()
    open(dijkPath) do dijkFile
      while !eof(dijkFile)
        pathLine = readline(dijkFile)
        pathTokens = split(pathLine)
        pStart = labels[parse(Int, pathTokens[2])+1]
        pEnd = labels[parse(Int, pathTokens[4])+1]
        name = string(pStart, "---", pEnd)
        cloudLine = readline(dijkFile)
        set = Set{String}()
        for token in split(cloudLine)
          push!(set, token)
        end
        clouds[name] = set
      end
    end

    keyArr = collect(keys(clouds))
    @assert endK < length(keyArr)
    SimMatrix = Matrix{Float64}(length(keyArr), length(keyArr))
    for i in 1:length(keyArr)
      for j in i:length(keyArr)
        if i == j
          sim = 1
        else
          verbose && println("Sim:", keyArr[i], keyArr[j])
          sim = setSimilarity(clouds[keyArr[i]], clouds[keyArr[j]])
        end
        SimMatrix[i, j] = sim
        SimMatrix[j, i] = sim
      end
    end
  end

  if writePath != nothing
    verbose && println("Writing Sim Matrix")
    open(writePath, "w") do file
      serialize(file, (keyArr, SimMatrix))
    end
  end

  W, H = RunNMFk(SimMatrix, startK:endK)

  clusters = sortrows([keyArr [findmax(H[:,i])[2] for i in 1:size(H, 2)]], by=x->x[2])


  open(resFilePath, "w") do file
    serialize(file, (clusters, W, H))
  end



end

function setSimilarity(A::Set, B::Set)
  return 2*(length(intersect(A,B))) / (length(A) + length(B))
end

function RunNMFk(A :: Matrix, kRange :: Range)

  res = NMFk.execute(A, kRange)

  # res is a 5 dim array with:
  # Ws, Hs, Fit, Sil, AIC
  largestDrop = 0
  bestK = kRange[1]
  for idx in kRange
    if idx < kRange[end]
      drop = abs(res[4][idx] - res[4][idx+1])
      #  verbose && println("Drop from $idx to $(idx+1) is $drop")
      if largestDrop < drop
        largestDrop = drop
        bestK = idx
      end
    end
  end

  return (res[1][bestK], res[2][bestK])

  clusters = zeros(size(res[2][bestK]))
  # this is gross code which means
  # we are putting a 1 in clusters[i][j]
  # if topic j is in cluster i
  clusters[findmax(res[2][bestK], 1)[2]] = 1
  for topic in 1:size(clusters, 2)
    clusterId = findmax(clusters[:, topic])[2]
  end
end

main()
